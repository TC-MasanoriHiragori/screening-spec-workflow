{
  "id": "snapshot_1770885306205_58sf8ya9i",
  "approvalId": "approval_1770885306201_kb061dneq",
  "approvalTitle": "Structure Steering Document - プロジェクト構造定義",
  "version": 1,
  "timestamp": "2026-02-12T08:35:06.205Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Project Structure\n\n## Directory Organization\n\nオニオンアーキテクチャに基づいた階層構造を採用します。依存関係は外側から内側へ向かい、内側の層は外側の層に依存しません。\n\n```text\nscreening-spec-workflow/\n├── src/\n│   └── screening_api/                 # メインアプリケーションパッケージ\n│       ├── domain/                    # ドメイン層（最内層・依存ゼロ）\n│       │   ├── entities/             # エンティティ\n│       │   ├── value_objects/        # 値オブジェクト\n│       │   ├── repositories/         # リポジトリインターフェース（抽象）\n│       │   └── services/             # ドメインサービス\n│       ├── application/               # アプリケーション層（ユースケース）\n│       │   ├── use_cases/            # ユースケース実装\n│       │   ├── dtos/                 # データ転送オブジェクト\n│       │   └── interfaces/           # アプリケーション層のインターフェース\n│       ├── infrastructure/            # インフラストラクチャ層\n│       │   ├── repositories/         # リポジトリ実装（将来的に使用）\n│       │   ├── external/             # 外部API連携（将来的に使用）\n│       │   └── config/               # 設定管理\n│       └── presentation/              # プレゼンテーション層（最外層）\n│           ├── api/                  # FastAPI エンドポイント\n│           │   ├── routes/           # ルーター定義\n│           │   ├── schemas/          # Pydantic リクエスト/レスポンススキーマ\n│           │   └── dependencies/     # FastAPI 依存性注入\n│           └── main.py               # FastAPIアプリケーションエントリーポイント\n├── tests/                             # テストディレクトリ\n│   ├── unit/                         # ユニットテスト（層ごとに分離）\n│   │   ├── domain/                   # ドメイン層のテスト\n│   │   ├── application/              # アプリケーション層のテスト\n│   │   └── infrastructure/           # インフラ層のテスト\n│   ├── integration/                  # 統合テスト\n│   └── e2e/                          # End-to-End テスト（API レベル）\n├── openapi.yaml                       # OpenAPI 仕様書（自動生成または手動管理）\n├── pyproject.toml                     # プロジェクト設定（uv管理）\n├── uv.lock                            # 依存関係ロックファイル\n├── ruff.toml                          # Ruff Linter/Formatter 設定\n├── .spec-workflow/                    # 仕様駆動開発ワークフローディレクトリ\n│   ├── specs/                        # 機能仕様書\n│   ├── steering/                     # ステアリングドキュメント\n│   └── templates/                    # テンプレート\n└── README.md                          # プロジェクト概要\n```\n\n## Naming Conventions\n\n### Files\n\nPythonの標準的な命名規則に従います：\n\n- **モジュール/パッケージ**: `snake_case`（例: `screening_service.py`, `use_cases/`）\n- **クラス定義ファイル**: クラス名と一致させる（例: `ScreeningRequest` クラス → `screening_request.py`）\n- **テストファイル**: `test_[対象ファイル名].py`（例: `test_screening_service.py`）\n- **設定ファイル**: `snake_case`（例: `app_config.py`）\n\n### Code\n\nPython標準のPEP 8に準拠：\n\n- **Classes/Types**: `PascalCase`（例: `ScreeningRequest`, `CandidateEntity`）\n- **Functions/Methods**: `snake_case`（例: `screen_candidate()`, `get_result()`）\n- **Constants**: `UPPER_SNAKE_CASE`（例: `MAX_TEXT_LENGTH`, `DEFAULT_RESPONSE`）\n- **Variables**: `snake_case`（例: `candidate_data`, `result_list`）\n- **Private members**: アンダースコア接頭辞（例: `_internal_method()`, `_private_var`）\n\n## Import Patterns\n\n### Import Order\n\nRuff（isort互換）による自動整形に従います：\n\n1. **標準ライブラリ**: `import os`, `from typing import ...`\n2. **サードパーティ**: `from fastapi import ...`, `import pydantic`\n3. **ファーストパーティ（自プロジェクト）**: `from screening_api.domain import ...`\n4. **相対インポート**: `from . import ...`, `from .. import ...`\n\n各グループ間には空行を挿入します。\n\n### Module/Package Organization\n\n```python\n# 標準ライブラリ\nfrom typing import Optional\nfrom datetime import datetime\n\n# サードパーティ\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\n\n# 自プロジェクト（絶対インポート推奨）\nfrom screening_api.domain.entities import CandidateEntity\nfrom screening_api.application.use_cases import ScreeningUseCase\nfrom screening_api.presentation.api.schemas import ScreeningRequest\n\n# 相対インポート（同一モジュール内のみ）\nfrom .dependencies import get_screening_service\n```\n\n**依存関係のルール**:\n- プレゼンテーション層 → アプリケーション層、ドメイン層\n- アプリケーション層 → ドメイン層\n- インフラストラクチャ層 → ドメイン層（インターフェース実装）\n- ドメイン層 → **依存なし**（純粋なビジネスロジック）\n\n## Code Structure Patterns\n\n### Module/Class Organization\n\nファイル内の標準的な構成順序：\n\n```python\n\"\"\"\nモジュールのDocstring（目的と責務を記述）\n\"\"\"\n\n# 1. Imports（上記のImport Order に従う）\nfrom typing import Protocol\n\n# 2. Constants（モジュールレベル定数）\nMAX_CANDIDATE_TEXT_LENGTH = 5000\n\n# 3. Type/Interface Definitions（プロトコル、型エイリアス）\nclass ScreeningRepository(Protocol):\n    \"\"\"リポジトリインターフェース\"\"\"\n    def save(self, data: dict) -> None: ...\n\n# 4. Main Implementation（クラス、関数）\nclass ScreeningService:\n    \"\"\"スクリーニングサービス実装\"\"\"\n\n    def __init__(self, repository: ScreeningRepository) -> None:\n        self._repository = repository\n\n    def screen(self, text: str) -> dict:\n        \"\"\"スクリーニング実行\"\"\"\n        # 実装...\n\n# 5. Helper/Utility Functions（プライベート関数）\ndef _validate_text(text: str) -> bool:\n    \"\"\"内部バリデーション\"\"\"\n    return len(text) <= MAX_CANDIDATE_TEXT_LENGTH\n\n# 6. Exports（__all__ による公開API定義）\n__all__ = [\"ScreeningService\", \"MAX_CANDIDATE_TEXT_LENGTH\"]\n```\n\n### Function/Method Organization\n\n関数内部の推奨構成：\n\n```python\ndef screen_candidate(candidate_text: str) -> dict:\n    \"\"\"候補者のスクリーニングを実行\"\"\"\n\n    # 1. Input validation（入力検証）\n    if not candidate_text:\n        raise ValueError(\"Candidate text is required\")\n\n    if len(candidate_text) > MAX_TEXT_LENGTH:\n        raise ValueError(\"Text too long\")\n\n    # 2. Core logic（コアロジック）\n    result = _perform_screening(candidate_text)\n\n    # 3. Return（明確な戻り値）\n    return {\n        \"status\": \"processed\",\n        \"result\": result,\n        \"timestamp\": datetime.now().isoformat()\n    }\n```\n\n### File Organization Principles\n\n- **1ファイル1クラス原則**: 大きなクラスは1ファイルに1つ。小さな関連クラスは同一ファイルに配置可\n- **Public API優先**: 公開クラス/関数を先に、プライベート実装を後に配置\n- **責務の明確化**: 各ファイルは単一の責務を持つ（例: `screening_service.py` はスクリーニングロジックのみ）\n\n## Code Organization Principles\n\n1. **Single Responsibility（単一責任の原則）**: 各モジュール、クラス、関数は1つの明確な責務のみを持つ\n2. **Dependency Inversion（依存性逆転の原則）**: 具象ではなく抽象（Protocol）に依存する\n3. **Testability（テスト容易性）**: 依存性注入を活用し、モックによるテストを可能にする\n4. **Consistency（一貫性）**: プロジェクト全体で命名規則、構造パターンを統一\n\n## Module Boundaries\n\n各層間の境界と依存関係のルール：\n\n### 依存関係の方向\n\n```text\nPresentation Layer\n       ↓ (depends on)\n  Application Layer\n       ↓ (depends on)\n    Domain Layer ← Infrastructure Layer (implements interfaces)\n```\n\n### 層ごとの責務\n\n- **Domain Layer（ドメイン層）**:\n  - ビジネスロジックとルールの定義\n  - フレームワーク非依存\n  - 外部ライブラリへの依存を最小化\n  - 他の層に依存してはいけない\n\n- **Application Layer（アプリケーション層）**:\n  - ユースケースのオーケストレーション\n  - ドメイン層のみに依存\n  - トランザクション管理\n  - ビジネスフローの調整\n\n- **Infrastructure Layer（インフラストラクチャ層）**:\n  - ドメイン層のインターフェース実装\n  - データベース、外部API、ファイルシステムとの連携\n  - フレームワーク固有の実装\n\n- **Presentation Layer（プレゼンテーション層）**:\n  - HTTP APIエンドポイント\n  - リクエスト/レスポンスの変換\n  - 認証・認可（将来実装）\n  - エラーハンドリング\n\n### 境界の強制\n\n- **型チェック**: mypyまたはPyright（将来導入検討）で依存関係を静的チェック\n- **Import制御**: Ruffのルールでドメイン層からの不正なインポートを禁止\n- **テスト**: 各層のユニットテストで依存関係を検証\n\n## Code Size Guidelines\n\nコード品質を保つためのガイドライン：\n\n- **File size（ファイルサイズ）**: 300行以内を推奨、500行を超えたら分割を検討\n- **Function/Method size（関数サイズ）**: 50行以内を推奨、100行を超える場合は分割\n- **Class complexity（クラス複雑度）**: メソッド数10以内、フィールド数5以内を推奨\n- **Nesting depth（ネスト深度）**: 4レベル以内（深すぎる場合はヘルパー関数に抽出）\n\nRuffによる自動チェック：\n- 行長: 88文字（Black互換）\n- 複雑度: McCabe複雑度 10以下（Ruff C901ルール）\n\n## Dashboard/Monitoring Structure (if applicable)\n\n初期実装では専用ダッシュボードは提供しません。\n\n将来的に管理ダッシュボードを追加する場合の推奨構造：\n\n```text\nsrc/\n└── screening_api/\n    └── dashboard/           # 独立したダッシュボードモジュール\n        ├── server.py       # ダッシュボード専用サーバー\n        ├── static/         # 静的ファイル（HTML, CSS, JS）\n        └── templates/      # テンプレートファイル\n```\n\n**分離の原則**:\n- ダッシュボードはコアAPIから独立\n- 別のエントリーポイントで起動可能\n- コアビジネスロジックに依存しない\n\n## Documentation Standards\n\nドキュメンテーションのルール：\n\n- **Docstrings**: すべての公開クラス、関数に必須（Google Styleまたは NumPy Style）\n- **型ヒント**: すべての関数シグネチャに型ヒントを付与（PEP 484）\n- **インラインコメント**: 複雑なロジックには簡潔な説明を追加\n- **README**: 各主要モジュール（domain, application等）にREADME.mdを配置\n- **OpenAPI**: FastAPIによる自動生成、`openapi.yaml` として出力\n\n### Docstring 例\n\n```python\ndef screen_candidate(candidate_text: str, threshold: float = 0.5) -> dict:\n    \"\"\"\n    候補者情報をスクリーニングします。\n\n    Args:\n        candidate_text: 候補者のテキスト情報\n        threshold: スクリーニング閾値（0.0〜1.0）\n\n    Returns:\n        スクリーニング結果を含む辞書\n            - status: 処理ステータス\n            - score: スコア\n            - recommendation: 推奨アクション\n\n    Raises:\n        ValueError: テキストが空または長すぎる場合\n    \"\"\"\n    # 実装...\n```\n\n## Testing Structure\n\nテストディレクトリの構成原則：\n\n- **テストはsrc構造を反映**: `tests/unit/domain/` は `src/screening_api/domain/` に対応\n- **テストの独立性**: 各テストは他のテストに依存せず実行可能\n- **Fixture活用**: `conftest.py` で共通Fixtureを定義\n- **命名規則**: `test_<対象機能>_<条件>_<期待結果>()`（例: `test_screen_candidate_with_valid_text_returns_success()`）\n\n### テスト構成例\n\n```text\ntests/\n├── conftest.py                      # 共通Fixture定義\n├── unit/\n│   ├── domain/\n│   │   └── test_screening_service.py\n│   ├── application/\n│   │   └── test_screening_use_case.py\n│   └── infrastructure/\n│       └── test_candidate_repository.py\n├── integration/\n│   └── test_api_integration.py\n└── e2e/\n    └── test_screening_endpoint.py\n```\n\n## Configuration Management\n\n設定管理の方針：\n\n- **環境変数**: 環境依存の設定（デプロイ先URL、ポート等）は環境変数で管理\n- **設定ファイル**: `src/screening_api/infrastructure/config/settings.py` に集約\n- **Pydantic Settings**: `pydantic-settings` で型安全な設定管理\n- **シークレット管理**: `.env` ファイル（`.gitignore`対象）または外部シークレット管理サービス\n\n### 設定例\n\n```python\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    \"\"\"アプリケーション設定\"\"\"\n    app_name: str = \"Screening API\"\n    api_version: str = \"v1\"\n    debug: bool = False\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\nsettings = Settings()\n```\n",
  "fileStats": {
    "size": 14120,
    "lines": 353,
    "lastModified": "2026-02-12T08:35:00.723Z"
  },
  "comments": []
}