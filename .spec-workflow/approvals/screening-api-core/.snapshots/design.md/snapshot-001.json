{
  "id": "snapshot_1770886362841_q92mz9pj3",
  "approvalId": "approval_1770886362836_jlnl3otlu",
  "approvalTitle": "Design - screening-api-core 設計",
  "version": 1,
  "timestamp": "2026-02-12T08:52:42.841Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\n「screening-api-core」は、オニオンアーキテクチャに基づく4層構造で構築される採用スクリーニングAPIのコア機能です。本設計では、FastAPIをプレゼンテーション層のフレームワークとして使用し、ドメイン駆動設計（DDD）の原則に従って、ビジネスロジックをフレームワークから独立させます。\n\n初期実装では、スクリーニングロジックは「入力値をそのまま返す」シンプルな実装とし、将来的な機械学習モデルやルールエンジンへの置き換えを容易にするため、依存性逆転の原則を適用したインターフェースベースの設計を採用します。\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n本設計は tech.md で定義された技術スタックを採用します：\n\n- **Python 3.12**: 最新の型ヒント機能を活用\n- **FastAPI**: 自動OpenAPI生成、Pydanticバリデーション\n- **uv**: 依存関係管理とプロジェクト管理\n- **pytest**: ユニットテスト、統合テスト\n- **ruff**: Linter/Formatter\n\n**アーキテクチャパターン**:\n- オニオンアーキテクチャ + DDD\n- 依存性逆転の原則（Dependency Inversion Principle）\n- インターフェースベースの設計（Protocol）\n\n### Project Structure (structure.md)\n\n本設計は structure.md で定義されたディレクトリ構成に従います：\n\n```text\napp/\n├── presentation/          # プレゼンテーション層\n│   ├── api/\n│   │   ├── routes/       # FastAPI ルーター\n│   │   └── schemas/      # Pydantic スキーマ\n│   └── main.py           # FastAPI アプリケーション\n├── usecase/              # アプリケーション層\n│   └── screening_usecase.py\n├── domain/               # ドメイン層\n│   └── screening_service.py  # インターフェース定義\n└── infrastructure/       # インフラストラクチャ層\n    └── screening_service_impl.py  # 実装\n```\n\n**命名規則**:\n- モジュール: `snake_case`\n- クラス: `PascalCase`\n- 関数: `snake_case`\n- 定数: `UPPER_SNAKE_CASE`\n\n## Code Reuse Analysis\n\n本仕様は新規プロジェクトのため、既存コードの再利用は該当しません。ただし、以下の標準的なPythonライブラリとパターンを活用します。\n\n### Existing Components to Leverage\n\n- **FastAPI**: RESTful APIフレームワーク、自動OpenAPI生成\n- **Pydantic**: データバリデーション、シリアライゼーション\n- **typing.Protocol**: インターフェース定義（Duck Typing）\n\n### Integration Points\n\n初期実装では外部システムとの統合はありません。将来的な統合ポイント：\n\n- **認証サービス**: 外部認証プロバイダー（Auth0、Firebase Auth等）\n- **機械学習API**: スクリーニングロジックの高度化\n- **データベース**: 評価結果の永続化\n\n## Architecture\n\n### 全体アーキテクチャ\n\nオニオンアーキテクチャに基づく4層構造を採用します。依存関係は外側から内側へ向かい、内側の層は外側の層に依存しません。\n\n```mermaid\ngraph TD\n    Client[HTTPクライアント]\n\n    subgraph Presentation[\"Presentation Layer (FastAPI)\"]\n        Router[APIルーター<br/>routes/screenings.py<br/>routes/health.py]\n        Schema[Pydanticスキーマ<br/>schemas/screening.py]\n    end\n\n    subgraph Application[\"Application Layer (Usecase)\"]\n        Usecase[ScreeningUsecase<br/>usecase/screening_usecase.py]\n    end\n\n    subgraph Domain[\"Domain Layer (Interface)\"]\n        Interface[ScreeningService Protocol<br/>domain/screening_service.py]\n    end\n\n    subgraph Infrastructure[\"Infrastructure Layer (Implementation)\"]\n        Implementation[EchoScreeningService<br/>infrastructure/screening_service_impl.py]\n    end\n\n    Client -->|HTTP Request| Router\n    Router -->|依存| Schema\n    Router -->|依存| Usecase\n    Usecase -->|依存| Interface\n    Implementation -.->|実装| Interface\n    Usecase -->|DI注入| Implementation\n\n    style Domain fill:#e1f5e1\n    style Infrastructure fill:#fff4e6\n```\n\n### 依存関係のルール\n\n1. **Presentation層** → Application層、Domain層\n2. **Application層** → Domain層のみ\n3. **Infrastructure層** → Domain層（インターフェース実装）\n4. **Domain層** → 依存なし（Pure Python）\n\n### Modular Design Principles\n\n- **Single File Responsibility**: 各ファイルは単一の責務を持つ\n  - `routes/screenings.py`: スクリーニングエンドポイントのみ\n  - `routes/health.py`: ヘルスチェックエンドポイントのみ\n  - `screening_usecase.py`: スクリーニングユースケースのみ\n\n- **Component Isolation**: 各層のコンポーネントは独立してテスト可能\n  - Domain層のインターフェースはFastAPI非依存\n  - Infrastructure層の実装はモック可能\n\n- **Service Layer Separation**: 層ごとに責務を明確に分離\n  - Presentation: HTTPリクエスト/レスポンス処理\n  - Application: ユースケースのオーケストレーション\n  - Domain: ビジネスロジックのインターフェース定義\n  - Infrastructure: 外部依存の実装\n\n- **Utility Modularity**: 共通処理は独立した小さなモジュールに分割（将来的に必要に応じて）\n\n## Components and Interfaces\n\n### Component 1: APIルーター（Presentation層）\n\n**ファイル**: `app/presentation/api/routes/screenings.py`\n\n- **Purpose**: スクリーニングエンドポイント `/v1/screenings` の処理\n- **Interfaces**:\n  ```python\n  @router.post(\"/v1/screenings\", response_model=ScreeningResponse)\n  async def create_screening(request: ScreeningRequest) -> ScreeningResponse:\n      \"\"\"スクリーニングリクエストを処理\"\"\"\n  ```\n- **Dependencies**:\n  - `ScreeningRequest` (Pydantic スキーマ)\n  - `ScreeningResponse` (Pydantic スキーマ)\n  - `ScreeningUsecase` (Application層)\n- **Reuses**: FastAPI の `APIRouter`, `Depends`\n\n**ファイル**: `app/presentation/api/routes/health.py`\n\n- **Purpose**: ヘルスチェックエンドポイント `/health` の処理\n- **Interfaces**:\n  ```python\n  @router.get(\"/health\", response_model=HealthResponse)\n  async def health_check() -> HealthResponse:\n      \"\"\"ヘルスチェック\"\"\"\n  ```\n- **Dependencies**:\n  - `HealthResponse` (Pydantic スキーマ)\n- **Reuses**: FastAPI の `APIRouter`\n\n### Component 2: Pydanticスキーマ（Presentation層）\n\n**ファイル**: `app/presentation/api/schemas/screening.py`\n\n- **Purpose**: リクエスト/レスポンスのデータバリデーションとシリアライゼーション\n- **Interfaces**:\n  ```python\n  class ScreeningRequest(BaseModel):\n      content: str\n\n  class ScreeningResponse(BaseModel):\n      content: str\n\n  class HealthResponse(BaseModel):\n      status: str\n  ```\n- **Dependencies**: `pydantic.BaseModel`\n- **Reuses**: Pydantic のバリデーション機能\n\n### Component 3: ScreeningUsecase（Application層）\n\n**ファイル**: `app/usecase/screening_usecase.py`\n\n- **Purpose**: スクリーニングユースケースのオーケストレーション\n- **Interfaces**:\n  ```python\n  class ScreeningUsecase:\n      def __init__(self, screening_service: ScreeningService):\n          self._service = screening_service\n\n      def execute(self, content: str) -> str:\n          \"\"\"スクリーニングを実行し、結果を返す\"\"\"\n  ```\n- **Dependencies**:\n  - `ScreeningService` (Domain層のインターフェース)\n- **Reuses**: なし（Pure Python）\n\n### Component 4: ScreeningService Protocol（Domain層）\n\n**ファイル**: `app/domain/screening_service.py`\n\n- **Purpose**: スクリーニングサービスのインターフェース定義\n- **Interfaces**:\n  ```python\n  from typing import Protocol\n\n  class ScreeningService(Protocol):\n      def screen(self, content: str) -> str:\n          \"\"\"スクリーニングを実行し、結果を返す\"\"\"\n          ...\n  ```\n- **Dependencies**: `typing.Protocol` のみ\n- **Reuses**: Pythonの `Protocol` による構造的部分型（Structural Subtyping）\n\n### Component 5: EchoScreeningService（Infrastructure層）\n\n**ファイル**: `app/infrastructure/screening_service_impl.py`\n\n- **Purpose**: スクリーニングサービスの具体的実装（入力値をそのまま返す）\n- **Interfaces**:\n  ```python\n  class EchoScreeningService:\n      def screen(self, content: str) -> str:\n          \"\"\"入力値をそのまま返す暫定実装\"\"\"\n          return content\n  ```\n- **Dependencies**: なし（Pure Python）\n- **Reuses**: なし\n\n### Component 6: FastAPIアプリケーション（Presentation層）\n\n**ファイル**: `app/presentation/main.py`\n\n- **Purpose**: FastAPIアプリケーションのエントリーポイント、ルーター登録、依存性注入の設定\n- **Interfaces**:\n  ```python\n  app = FastAPI(title=\"Screening API\", version=\"1.0.0\")\n  app.include_router(screenings_router)\n  app.include_router(health_router)\n  ```\n- **Dependencies**:\n  - `screenings_router` (routes/screenings.py)\n  - `health_router` (routes/health.py)\n- **Reuses**: FastAPI の `FastAPI`, `APIRouter`\n\n## Data Models\n\n### ScreeningRequest（リクエストモデル）\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass ScreeningRequest(BaseModel):\n    \"\"\"スクリーニングリクエスト\"\"\"\n    content: str = Field(..., description=\"スクリーニング対象のテキスト\")\n\n    model_config = {\n        \"json_schema_extra\": {\n            \"examples\": [\n                {\"content\": \"応募者情報のテキスト\"}\n            ]\n        }\n    }\n```\n\n### ScreeningResponse（レスポンスモデル）\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass ScreeningResponse(BaseModel):\n    \"\"\"スクリーニングレスポンス\"\"\"\n    content: str = Field(..., description=\"処理結果（入力値のエコー）\")\n\n    model_config = {\n        \"json_schema_extra\": {\n            \"examples\": [\n                {\"content\": \"応募者情報のテキスト\"}\n            ]\n        }\n    }\n```\n\n### HealthResponse（ヘルスチェックレスポンス）\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass HealthResponse(BaseModel):\n    \"\"\"ヘルスチェックレスポンス\"\"\"\n    status: str = Field(default=\"ok\", description=\"ヘルスステータス\")\n```\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. バリデーションエラー（422 Unprocessable Entity）\n\n- **Scenario**: リクエストボディが不正なJSON形式、または `content` フィールドが存在しない\n- **Handling**:\n  - FastAPI + Pydantic の自動バリデーション機能により検出\n  - HTTPステータス 422 を返す\n  - エラー詳細を含むJSONレスポンスを返す\n- **User Impact**:\n  ```json\n  {\n    \"detail\": [\n      {\n        \"type\": \"missing\",\n        \"loc\": [\"body\", \"content\"],\n        \"msg\": \"Field required\",\n        \"input\": {}\n      }\n    ]\n  }\n  ```\n\n#### 2. Content-Type エラー（415 Unsupported Media Type）\n\n- **Scenario**: リクエストの Content-Type が `application/json` でない\n- **Handling**:\n  - FastAPI が自動的に検出し、HTTPステータス 415 を返す\n- **User Impact**:\n  ```json\n  {\n    \"detail\": \"Content-Type must be application/json\"\n  }\n  ```\n\n#### 3. サーバーエラー（500 Internal Server Error）\n\n- **Scenario**: 予期しない内部エラーが発生\n- **Handling**:\n  - FastAPI のグローバルエラーハンドラーで捕捉\n  - エラーログを出力\n  - HTTPステータス 500 を返す\n  - 内部エラー詳細は隠蔽し、汎用的なエラーメッセージを返す\n- **User Impact**:\n  ```json\n  {\n    \"detail\": \"Internal server error\"\n  }\n  ```\n\n### エラーハンドリング戦略\n\n- **Pydanticバリデーション**: 入力データの自動検証\n- **FastAPI例外ハンドラー**: グローバルエラーハンドリング\n- **ログ出力**: エラー発生時の詳細ログ（開発環境では詳細、本番環境では最小限）\n- **セキュリティ**: 内部実装の詳細を外部に漏らさない\n\n## Testing Strategy\n\n### Unit Testing\n\n各層を独立してテストします。\n\n#### Domain層のテスト\n\n**ファイル**: `tests/unit/domain/test_screening_service.py`\n\n- **テスト対象**: `ScreeningService` Protocol（型定義の確認）\n- **テストケース**:\n  - Protocol に準拠した実装が正しく動作することを確認\n\n#### Application層のテスト\n\n**ファイル**: `tests/unit/usecase/test_screening_usecase.py`\n\n- **テスト対象**: `ScreeningUsecase`\n- **テストケース**:\n  - `execute()` メソッドが `ScreeningService.screen()` を正しく呼び出すことを確認\n  - モック（`MagicMock`）を使用して `ScreeningService` をモック化\n  - 入力値が正しく渡され、戻り値が正しく返されることを確認\n\n#### Infrastructure層のテスト\n\n**ファイル**: `tests/unit/infrastructure/test_screening_service_impl.py`\n\n- **テスト対象**: `EchoScreeningService`\n- **テストケース**:\n  - `screen()` メソッドが入力値をそのまま返すことを確認\n  - 空文字列、長文テキストなど、境界値のテスト\n\n#### Presentation層のテスト\n\n**ファイル**: `tests/unit/presentation/test_schemas.py`\n\n- **テスト対象**: Pydantic スキーマ（`ScreeningRequest`, `ScreeningResponse`, `HealthResponse`）\n- **テストケース**:\n  - 正しいデータでバリデーションが成功することを確認\n  - 不正なデータでバリデーションが失敗することを確認\n\n### Integration Testing\n\n各層を統合してテストします。\n\n**ファイル**: `tests/integration/test_screening_integration.py`\n\n- **テスト対象**: Presentation層 → Application層 → Infrastructure層の統合\n- **テストケース**:\n  - FastAPI `TestClient` を使用して実際のHTTPリクエストをシミュレート\n  - `/v1/screenings` エンドポイントに正常なリクエストを送信し、正しいレスポンスが返ることを確認\n  - 不正なリクエストに対して適切なエラーレスポンスが返ることを確認\n\n**ファイル**: `tests/integration/test_health_integration.py`\n\n- **テスト対象**: `/health` エンドポイント\n- **テストケース**:\n  - `/health` エンドポイントにリクエストを送信し、`{\"status\": \"ok\"}` が返ることを確認\n\n### End-to-End Testing\n\n**ファイル**: `tests/e2e/test_api_e2e.py`\n\n- **テスト対象**: API全体の動作\n- **テストケース**:\n  - 実際のアプリケーションを起動し、HTTPクライアント（`httpx`）でリクエストを送信\n  - `/v1/screenings` と `/health` の両エンドポイントが正常に動作することを確認\n\n### テストカバレッジ目標\n\n- **ユニットテスト**: 各層で 80% 以上のコードカバレッジ\n- **統合テスト**: エンドポイントごとの主要パスを網羅\n- **E2Eテスト**: 主要なユーザーシナリオを網羅\n\n## Deployment Considerations\n\n### 開発環境\n\n- **起動コマンド**: `uv run fastapi dev app/presentation/main.py`\n- **ホットリロード**: FastAPI の開発モードで自動リロード\n- **ポート**: デフォルト 8000\n\n### OpenAPI仕様書の生成\n\n- **自動生成**: FastAPI が `/openapi.json` エンドポイントで自動生成\n- **YAML出力**: 以下のスクリプトで `openapi.yaml` を生成\n  ```python\n  import json\n  import yaml\n  from app.presentation.main import app\n\n  openapi_json = app.openapi()\n  with open(\"openapi.yaml\", \"w\") as f:\n      yaml.dump(openapi_json, f, sort_keys=False)\n  ```\n\n### 依存性注入\n\nFastAPI の `Depends` を使用して、Infrastructure層の実装をPresentation層に注入します。\n\n**ファイル**: `app/presentation/api/dependencies.py`\n\n```python\nfrom app.domain.screening_service import ScreeningService\nfrom app.infrastructure.screening_service_impl import EchoScreeningService\nfrom app.usecase.screening_usecase import ScreeningUsecase\n\ndef get_screening_service() -> ScreeningService:\n    \"\"\"ScreeningService の実装を返す\"\"\"\n    return EchoScreeningService()\n\ndef get_screening_usecase(\n    service: ScreeningService = Depends(get_screening_service)\n) -> ScreeningUsecase:\n    \"\"\"ScreeningUsecase のインスタンスを返す\"\"\"\n    return ScreeningUsecase(service)\n```\n\n**ルーターでの使用**:\n\n```python\n@router.post(\"/v1/screenings\", response_model=ScreeningResponse)\nasync def create_screening(\n    request: ScreeningRequest,\n    usecase: ScreeningUsecase = Depends(get_screening_usecase)\n) -> ScreeningResponse:\n    result = usecase.execute(request.content)\n    return ScreeningResponse(content=result)\n```\n\n## Future Extensibility\n\n本設計は将来的な拡張を容易にします：\n\n### 高度なスクリーニングロジックへの置き換え\n\nInfrastructure層の実装を変更するだけで、Domain層とApplication層は変更不要：\n\n```python\n# 新しい実装例\nclass MLScreeningService:\n    \"\"\"機械学習ベースのスクリーニング実装\"\"\"\n    def screen(self, content: str) -> str:\n        # 機械学習モデルを呼び出す\n        result = ml_model.predict(content)\n        return result\n```\n\n依存性注入の設定を変更：\n\n```python\ndef get_screening_service() -> ScreeningService:\n    return MLScreeningService()  # 実装を変更\n```\n\n### 永続化層の追加\n\nInfrastructure層にリポジトリパターンを追加：\n\n```python\n# domain/screening_repository.py\nclass ScreeningRepository(Protocol):\n    def save(self, screening: Screening) -> None: ...\n\n# infrastructure/screening_repository_impl.py\nclass PostgresScreeningRepository:\n    def save(self, screening: Screening) -> None:\n        # データベースに保存\n```\n\n### 認証・認可の追加\n\nPresentation層に認証ミドルウェアを追加：\n\n```python\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\n\n@router.post(\"/v1/screenings\")\nasync def create_screening(\n    request: ScreeningRequest,\n    token: str = Depends(security)\n):\n    # トークン検証ロジック\n```\n",
  "fileStats": {
    "size": 18384,
    "lines": 545,
    "lastModified": "2026-02-12T08:52:37.662Z"
  },
  "comments": []
}